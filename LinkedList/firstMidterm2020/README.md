## Условия на задачите.
 
**1 задача:** Нека е даден следният шаблон на структура:
```
 template <class T>
 struct Node {
   T data; 
   Node<T> *next;
 };
 ```
Да се реализира функция reduce, която приема два параметъра: указател към първия елемент на линеен едносвързан списък L с възли от тип Node и двуместна функция F от тип (const T&, const T&) -> T. Резултатът  от изпълнението на reduce да е стойността при приложението на ляво-асоциативния оператор F последователно над елементите на L, или F(...F(F(l1, l2), l3) ...,lk), където l1, ...,lk са елементите на списъка L.
При K = 0 да се генерира подходяща грешка (изключение), а при K = 1 стойността на функцията да е l1.

**2 задача:** При условията на горната задача, нека е даден списък L с елементи стекове. Възлите на L са от тип Node<std::stack<T>>> (или друга готова реализация на стек, с която разполагате). Да се дефинира подходящо параметризирана функция equalize(L), която размества елементите на стековете така, че да няма два стека в L с разлика в броя на елементите, по-голяма от 1. <br />
#### Пример: <br />
Даден е списък от стекове и едно от възможните пренареждания на елементите на стековете. Разместените елементи са оградени в | |. <br />
<br />
<pre>
1 <br />
2             8 <br />
3             9                   3      |1|    9       |8| <br />
4      6      10                  4      6      10      |2| <br />
5  ->  7  ->  11  ->  12          5  ->  7  ->  11  ->  12 <br />
</pre>

**3 задача:** Нека е даден списък L с N елемента. Да се дефинира подходящо параметризирана функция shuffle,
която получава адреса на първия елемент на списъка. Функцията да пренарежда възлите на списъка така, че
елементите от втората половина на списъка да се преместят в началото на списъка, но в обратен ред (при
списъци с нечетен брой елементи считаме средния елемент за принадлежащ към първата половина на списъка).
#### Пример: <br />
L1 → L2 → L3 → L4 → L5  се преобразува до L5 → L4 → L1 → L2 → L3 <br />
<br />
При решението на задачата да не се изтриват или заделят нови възли, а да се използват съществуващите.
Могат да се използват други изучени структури от данни.
